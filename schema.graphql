schema {
  query: JukeboxQuery
  mutation: JukeboxMutation
  subscription: JukeboxSubscription
}

type Album {
  id: Int!
  title: String!
  artist: Artist! @cost(weight: "10")
  artistId: Int!
  tracks: [Track!]! @cost(weight: "10")
  reviews: [AlbumReview!]! @cost(weight: "10")
}

type AlbumReview {
  id: Int!
  author: String
  comment: String
  rating: Int
  upVote: Int!
  downVote: Int!
  timestamp: DateTime!
  albumId: Int!
  album: Album
}

type Artist {
  id: Int!
  name: String!
  albums: [Album!]! @cost(weight: "10")
}

type Category {
  id: Int!
  name: String
  tracks: [Track!]! @cost(weight: "10")
}

type JukeboxMutation {
  addAlbumReview(input: AddReviewInput!): Boolean! @cost(weight: "10")
  changeUserName(newName: String!): User!
}

type JukeboxQuery {
  categories: [Category!]! @cost(weight: "10")
  category(id: Int!): Category @cost(weight: "10")
  artists: [Artist!]! @cost(weight: "10")
  artist(id: Int!): Artist @cost(weight: "10")
  albums(where: AlbumFilterInput @cost(weight: "10") order: [AlbumSortInput!] @cost(weight: "10")): [Album!]! @cost(weight: "10")
  album(id: Int!): Album @cost(weight: "10")
  track(id: Int!): Track @cost(weight: "10")
  me: User!
}

type JukeboxSubscription {
  userUpdated(userId: Int!): User!
}

type MediaType {
  mediaTypeId: Int!
  name: String
}

type Track {
  "The track id"
  id: Int!
  "The track name"
  name: String!
  "The track duration in minutes and seconds (e.g 3m 20s)"
  duration: String @cost(weight: "10")
  album: Album
  albumId: Int!
  mediaTypeId: Int!
  genreId: Int!
  composer: String
  milliseconds: Int!
  bytes: Int!
  unitPrice: Decimal!
  mediaType: MediaType
  genre: Category
}

type User {
  id: Int!
  name: String!
}

input AddReviewInput {
  albumId: Int!
  comment: String!
  rating: Int
}

input AlbumFilterInput {
  and: [AlbumFilterInput!]
  or: [AlbumFilterInput!]
  albumId: IntOperationFilterInput
  title: StringOperationFilterInput
  artistId: IntOperationFilterInput
  artist: ArtistFilterInput
  tracks: ListFilterInputTypeOfTrackFilterInput
  reviews: ListFilterInputTypeOfAlbumReviewFilterInput
}

input AlbumReviewFilterInput {
  and: [AlbumReviewFilterInput!]
  or: [AlbumReviewFilterInput!]
  albumReviewId: IntOperationFilterInput
  timestamp: DateTimeOperationFilterInput
  author: StringOperationFilterInput
  rating: IntOperationFilterInput
  comment: StringOperationFilterInput
  upVote: IntOperationFilterInput
  downVote: IntOperationFilterInput
  albumId: IntOperationFilterInput
  album: AlbumFilterInput
}

input AlbumSortInput {
  albumId: SortEnumType @cost(weight: "10")
  title: SortEnumType @cost(weight: "10")
  artistId: SortEnumType @cost(weight: "10")
  artist: ArtistSortInput @cost(weight: "10")
}

input ArtistFilterInput {
  and: [ArtistFilterInput!]
  or: [ArtistFilterInput!]
  artistId: IntOperationFilterInput
  name: StringOperationFilterInput
  albums: ListFilterInputTypeOfAlbumFilterInput
}

input ArtistSortInput {
  artistId: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
}

input DateTimeOperationFilterInput {
  eq: DateTime @cost(weight: "10")
  neq: DateTime @cost(weight: "10")
  in: [DateTime] @cost(weight: "10")
  nin: [DateTime] @cost(weight: "10")
  gt: DateTime @cost(weight: "10")
  ngt: DateTime @cost(weight: "10")
  gte: DateTime @cost(weight: "10")
  ngte: DateTime @cost(weight: "10")
  lt: DateTime @cost(weight: "10")
  nlt: DateTime @cost(weight: "10")
  lte: DateTime @cost(weight: "10")
  nlte: DateTime @cost(weight: "10")
}

input DecimalOperationFilterInput {
  eq: Decimal @cost(weight: "10")
  neq: Decimal @cost(weight: "10")
  in: [Decimal] @cost(weight: "10")
  nin: [Decimal] @cost(weight: "10")
  gt: Decimal @cost(weight: "10")
  ngt: Decimal @cost(weight: "10")
  gte: Decimal @cost(weight: "10")
  ngte: Decimal @cost(weight: "10")
  lt: Decimal @cost(weight: "10")
  nlt: Decimal @cost(weight: "10")
  lte: Decimal @cost(weight: "10")
  nlte: Decimal @cost(weight: "10")
}

input GenreFilterInput {
  and: [GenreFilterInput!]
  or: [GenreFilterInput!]
  genreId: IntOperationFilterInput
  name: StringOperationFilterInput
  tracks: ListFilterInputTypeOfTrackFilterInput
}

input IntOperationFilterInput {
  eq: Int @cost(weight: "10")
  neq: Int @cost(weight: "10")
  in: [Int] @cost(weight: "10")
  nin: [Int] @cost(weight: "10")
  gt: Int @cost(weight: "10")
  ngt: Int @cost(weight: "10")
  gte: Int @cost(weight: "10")
  ngte: Int @cost(weight: "10")
  lt: Int @cost(weight: "10")
  nlt: Int @cost(weight: "10")
  lte: Int @cost(weight: "10")
  nlte: Int @cost(weight: "10")
}

input ListFilterInputTypeOfAlbumFilterInput {
  all: AlbumFilterInput @cost(weight: "10")
  none: AlbumFilterInput @cost(weight: "10")
  some: AlbumFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfAlbumReviewFilterInput {
  all: AlbumReviewFilterInput @cost(weight: "10")
  none: AlbumReviewFilterInput @cost(weight: "10")
  some: AlbumReviewFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfTrackFilterInput {
  all: TrackFilterInput @cost(weight: "10")
  none: TrackFilterInput @cost(weight: "10")
  some: TrackFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input MediaTypeFilterInput {
  and: [MediaTypeFilterInput!]
  or: [MediaTypeFilterInput!]
  mediaTypeId: IntOperationFilterInput
  name: StringOperationFilterInput
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String @cost(weight: "10")
  neq: String @cost(weight: "10")
  contains: String @cost(weight: "20")
  ncontains: String @cost(weight: "20")
  in: [String] @cost(weight: "10")
  nin: [String] @cost(weight: "10")
  startsWith: String @cost(weight: "20")
  nstartsWith: String @cost(weight: "20")
  endsWith: String @cost(weight: "20")
  nendsWith: String @cost(weight: "20")
}

input TrackFilterInput {
  and: [TrackFilterInput!]
  or: [TrackFilterInput!]
  trackId: IntOperationFilterInput
  name: StringOperationFilterInput
  albumId: IntOperationFilterInput
  mediaTypeId: IntOperationFilterInput
  genreId: IntOperationFilterInput
  composer: StringOperationFilterInput
  milliseconds: IntOperationFilterInput
  bytes: IntOperationFilterInput
  unitPrice: DecimalOperationFilterInput
  album: AlbumFilterInput
  mediaType: MediaTypeFilterInput
  genre: GenreFilterInput
}

enum SortEnumType {
  ASC
  DESC
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"The `Decimal` scalar type represents a decimal floating-point number."
scalar Decimal